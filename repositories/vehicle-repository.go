package repositories

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"time"

	dbconfig "github.com/aniket0951/testproject/db-config"
	"github.com/aniket0951/testproject/helper"
	"github.com/aniket0951/testproject/models"
	"github.com/aniket0951/testproject/proxyapis"
	"github.com/mashingan/smapping"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

var vehicleCollection *mongo.Collection = dbconfig.GetCollection(dbconfig.ResolveClientDB(), "vehicle_info")
var vehicleLocationCollection *mongo.Collection = dbconfig.GetCollection(dbconfig.ResolveClientDB(), "vehicles")
var vehicleAlertCollection = dbconfig.GetCollection(dbconfig.ResolveClientDB(), "vehicle_alerts")
var vehicleAlertHistoryCollection = dbconfig.GetCollection(dbconfig.ResolveClientDB(), "alert_history")
var alertMasterConfigCollection = dbconfig.GetCollection(dbconfig.ResolveClientDB(), "alert_config")
var vehicleFallAlertCollection = dbconfig.GetCollection(dbconfig.ResolveClientDB(), "vehicle_fall_alerts")

type VehicleRepository interface {
	AddUpdateVehicleInformation(vehicleInfo models.VehiclesData)
	RefreshVehicleData() ([]models.VehiclesData, error)
	UpdateVehicleData(vehicle models.VehiclesData) error
	AddVehicleLocationData(vehicleLocation models.VehicleLocationData)
	GetVehicleAlertById(vehicleId string) (models.VehicleAlerts, error)
	GetVehicleFallAlertById(vehicleId string) (models.VehicleFallAlerts, error)
	GetAllVehicleAlerts() ([]models.VehicleAlerts, error)
	GetAllVehicleFallAlerts() ([]models.VehicleFallAlerts, error)

	TrackVehicleAlert() ([]models.VehiclesData, error)
	UpdateVehicleAlert(vehicleData models.VehicleAlerts) error
	UpdateVehicleFallAlert(vehicleData models.VehicleFallAlerts) error
	CreateVehicleAlertHistory(vehicleAlerts []models.VehicleAlerts) error
	CreateVehicleFallAlertHistory(vehicleAlerts []models.VehicleFallAlerts) error
	DeleteTodayAlert(alertId primitive.ObjectID) error

	GetAlertLimit(alertType string) (int, error)
}

type vehiclerepository struct {
	vehicleCollection             *mongo.Collection
	vehicleLocationConnection     *mongo.Collection
	vehicleAlertConnection        *mongo.Collection
	vehicleAlertHistoryConnection *mongo.Collection
	alertConfigConnection         *mongo.Collection
	vehicleFallAlertsConnection   *mongo.Collection
}

func NewVehicleRepository() VehicleRepository {
	return &vehiclerepository{
		vehicleCollection:             vehicleCollection,
		vehicleLocationConnection:     vehicleLocationCollection,
		vehicleAlertConnection:        vehicleAlertCollection,
		vehicleAlertHistoryConnection: vehicleAlertHistoryCollection,
		alertConfigConnection:         alertMasterConfigCollection,
		vehicleFallAlertsConnection:   vehicleFallAlertCollection,
	}
}

func (db *vehiclerepository) AddUpdateVehicleInformation(vehicleInfo models.VehiclesData) {
	fmt.Println("repo get start", vehicleInfo)
	opt := options.FindOneAndReplace().SetUpsert(true)

	filter := bson.D{
		bson.E{Key: "vehicleno", Value: vehicleInfo.VehicleNo},
	}

	res := db.vehicleCollection.FindOneAndReplace(context.TODO(), filter, vehicleInfo, opt)
	fmt.Println("resul for update ", res.Err())
}

func (db *vehiclerepository) AddVehicleLocationData(vehicleLocation models.VehicleLocationData) {

	res, err := db.vehicleLocationConnection.InsertOne(context.Background(), vehicleLocation)

	if err != nil {
		fmt.Println(err.Error())
	}

	fmt.Println(vehicleLocation)

	fmt.Println(res.InsertedID)
}

func (db *vehiclerepository) RefreshVehicleData() ([]models.VehiclesData, error) {
	reqURL := "http://fusioniot.mobilogix.com/webservice?token=getLiveData&user=skroman@mautoafrica.com&pass=Mauto@777"

	requestChannel := make(chan models.AutoGenerated)
	go proxyapis.GetAllVehicels(reqURL, requestChannel)
	responseData := <-requestChannel

	if len(responseData.Root.VehicleData) <= 1 {
		return nil, errors.New("API time limit exceed")
	}

	var vehicleData []models.VehiclesData

	for i := range responseData.Root.VehicleData {
		temp := models.VehiclesData{}
		_ = smapping.FillStruct(&temp, smapping.MapFields(responseData.Root.VehicleData[i]))
		vehicleData = append(vehicleData, temp)
	}

	return vehicleData, nil
}

func (db *vehiclerepository) UpdateVehicleData(vehicle models.VehiclesData) error {
	opt := options.FindOneAndReplace().SetUpsert(true)

	filter := bson.D{
		bson.E{Key: "vehicleno", Value: vehicle.VehicleNo},
	}

	res := db.vehicleCollection.FindOneAndReplace(context.TODO(), filter, vehicle, opt)
	return res.Err()
}

func (db *vehiclerepository) GetVehicleAlertById(vehicleId string) (models.VehicleAlerts, error) {
	filter := bson.D{
		bson.E{Key: "bike_no", Value: vehicleId},
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var vehicleData models.VehicleAlerts

	_ = db.vehicleAlertConnection.FindOne(ctx, filter).Decode(&vehicleData)

	return vehicleData, nil
}

func (db *vehiclerepository) GetVehicleFallAlertById(vehicleId string) (models.VehicleFallAlerts, error) {
	filter := bson.D{
		bson.E{Key: "bike_no", Value: vehicleId},
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	var vehicleData models.VehicleFallAlerts

	_ = db.vehicleFallAlertsConnection.FindOne(ctx, filter).Decode(&vehicleData)

	return vehicleData, nil
}

func (db *vehiclerepository) TrackVehicleAlert() ([]models.VehiclesData, error) {
	reqURL := "http://fusioniot.mobilogix.com/webservice?token=getLiveData&user=skroman@mautoafrica.com&pass=Mauto@777"

	resp, err := http.Get(reqURL)
	if err != nil {
		fmt.Println("URL heat error => ", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			fmt.Println(err)
		}
	}(resp.Body)
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Read all error =>", err)
	}
	content := string(body)
	var jsonMap models.AutoGenerated
	_ = json.Unmarshal([]byte(content), &jsonMap)
	vehicleData := []models.VehiclesData{}

	for i := range jsonMap.Root.VehicleData {
		temp := models.VehiclesData{}
		smpErr := smapping.FillStruct(&temp, smapping.MapFields(jsonMap.Root.VehicleData[i]))

		if smpErr != nil {
			fmt.Println("SMP Error =>", smpErr.Error())
		}

		vehicleData = append(vehicleData, temp)
	}

	fmt.Println(len(vehicleData))
	return vehicleData, nil
}

func (db *vehiclerepository) UpdateVehicleAlert(vehicleData models.VehicleAlerts) error {

	vehicleData.CreateAt = primitive.NewDateTimeFromTime(time.Now())
	vehicleData.UpdateAt = primitive.NewDateTimeFromTime(time.Now())

	istTime := helper.ConvertUTCToIndia()
	vehicleData.ISTTimeStamp = istTime[0] + istTime[1]

	filter := bson.D{
		bson.E{Key: "bike_no", Value: vehicleData.BikeNo},
	}
	opts := options.FindOneAndReplace().SetUpsert(true)

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	_ = db.vehicleAlertConnection.FindOneAndReplace(ctx, filter, vehicleData, opts)

	return nil
}

func (db *vehiclerepository) UpdateVehicleFallAlert(vehicleData models.VehicleFallAlerts) error {

	vehicleData.CreateAt = primitive.NewDateTimeFromTime(time.Now())
	vehicleData.UpdateAt = primitive.NewDateTimeFromTime(time.Now())

	istTime := helper.ConvertUTCToIndia()
	vehicleData.ISTTimeStamp = istTime[0] + istTime[1]

	filter := bson.D{
		bson.E{Key: "bike_no", Value: vehicleData.BikeNo},
	}
	opts := options.FindOneAndReplace().SetUpsert(true)

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	_ = db.vehicleFallAlertsConnection.FindOneAndReplace(ctx, filter, vehicleData, opts)

	return nil
}

func (db *vehiclerepository) GetAllVehicleAlerts() ([]models.VehicleAlerts, error) {

	filter := []bson.M{
		{"$match": bson.M{
			"create_at": bson.M{
				"$lte": primitive.NewDateTimeFromTime(time.Now()),
			},
		},
		},
	}

	cursor, curErr := db.vehicleAlertConnection.Aggregate(context.TODO(), filter)

	if curErr != nil {
		return nil, curErr
	}

	var vehicleAlerts []models.VehicleAlerts

	if err := cursor.All(context.TODO(), &vehicleAlerts); err != nil {
		fmt.Println("error from query", err)
	}

	fmt.Println("Vehicle alerts =>", len(vehicleAlerts))

	return vehicleAlerts, nil
}

func (db *vehiclerepository) GetAllVehicleFallAlerts() ([]models.VehicleFallAlerts, error) {
	filter := []bson.M{
		{"$match": bson.M{
			"create_at": bson.M{
				"$lte": primitive.NewDateTimeFromTime(time.Now()),
			},
		},
		},
	}

	cursor, curErr := db.vehicleFallAlertsConnection.Aggregate(context.TODO(), filter)

	if curErr != nil {
		return nil, curErr
	}

	var vehicleAlerts []models.VehicleFallAlerts

	if err := cursor.All(context.TODO(), &vehicleAlerts); err != nil {
		fmt.Println("error from query", err)
	}

	fmt.Println("Vehicle alerts =>", len(vehicleAlerts))

	return vehicleAlerts, nil
}

func (db *vehiclerepository) CreateVehicleAlertHistory(vehicleAlerts []models.VehicleAlerts) error {

	for i := range vehicleAlerts {
		if (models.VehicleAlerts{} == vehicleAlerts[i]) {
			continue
		} else {

			temp := models.VehicleAlertHistory{}
			_ = smapping.FillStruct(&temp, smapping.MapFields(vehicleAlerts[i]))

			temp.Id = primitive.NewObjectID()
			temp.HistoryTimestamp = primitive.NewDateTimeFromTime(time.Now())
			temp.AlertType = "overspeed"

			res, err := db.vehicleAlertHistoryConnection.InsertOne(context.TODO(), temp)

			if err != nil {
				return err
			}

			fmt.Println("Insert Alert Result History => ", res)

			_ = db.DeleteTodayAlert(vehicleAlerts[i].Id)
		}

	}

	return nil
}

func (db *vehiclerepository) CreateVehicleFallAlertHistory(vehicleAlerts []models.VehicleFallAlerts) error {

	for i := range vehicleAlerts {
		if (models.VehicleFallAlerts{} == vehicleAlerts[i]) {
			continue
		} else {

			temp := models.VehicleFallAlertHistory{}
			_ = smapping.FillStruct(&temp, smapping.MapFields(vehicleAlerts[i]))

			temp.Id = primitive.NewObjectID()
			temp.HistoryTimestamp = primitive.NewDateTimeFromTime(time.Now())
			temp.AlertType = "fall"

			res, err := db.vehicleAlertHistoryConnection.InsertOne(context.TODO(), temp)

			if err != nil {
				return err
			}

			fmt.Println("Insert Alert Result History => ", res)

			_ = db.DeleteTodayAlert(vehicleAlerts[i].Id)
		}

	}

	return nil
}

func (db *vehiclerepository) DeleteTodayAlert(alertId primitive.ObjectID) error {

	filter := bson.D{
		bson.E{Key: "_id", Value: alertId},
	}

	res, err := db.vehicleAlertConnection.DeleteOne(context.TODO(), filter)

	fmt.Println("Delete alert history => ", res)

	return err
}

func (db *vehiclerepository) GetAlertLimit(alertType string) (int, error) {
	filter := bson.D{
		bson.E{Key: "alert_type", Value: alertType},
	}

	alertConfig := models.AlertConfig{}

	res := db.alertConfigConnection.FindOne(context.TODO(), filter).Decode(&alertConfig)
	if res != nil {
		return 0, res
	}

	return int(alertConfig.Limit), nil
}
